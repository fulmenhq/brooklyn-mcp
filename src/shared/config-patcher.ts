import { copyFileSync, existsSync, mkdirSync, readFileSync, writeFileSync } from "node:fs";
import { dirname } from "node:path";
// TOML parser
import * as TOML from "toml";

export interface PatchOptions {
  backup?: boolean;
  dryRun?: boolean;
}

function backupFile(path: string): string | undefined {
  if (!existsSync(path)) return undefined;
  const suffix = `.bak.${new Date().toISOString().replaceAll(":", "-").replace(".", "-")}`;
  const backupPath = `${path}${suffix}`;
  copyFileSync(path, backupPath);
  return backupPath;
}

export function ensureDirFor(path: string): void {
  mkdirSync(dirname(path), { recursive: true });
}

type JsonRoot = { mcpServers?: Record<string, unknown> };

export function patchJsonBrooklyn(
  path: string,
  value: unknown | null,
  opts: PatchOptions = {},
): {
  changed: boolean;
  backup?: string;
  preview: string;
} {
  let obj: Record<string, unknown> = {};
  if (existsSync(path)) {
    try {
      obj = JSON.parse(readFileSync(path, "utf8"));
    } catch {
      obj = {};
    }
  }
  if (typeof obj !== "object" || obj === null) obj = {} as Record<string, unknown>;
  const root = obj as JsonRoot;
  if (!root.mcpServers || typeof root.mcpServers !== "object")
    root.mcpServers = {} as Record<string, unknown>;

  const before = JSON.stringify(root);
  if (value === null) {
    const mcp = root.mcpServers as Record<string, unknown>;
    mcp["brooklyn"] = undefined;
    if (Object.keys(mcp).length === 0) root.mcpServers = undefined;
  } else {
    const mcp = root.mcpServers as Record<string, unknown>;
    mcp["brooklyn"] = value as unknown;
  }
  const after = JSON.stringify(root);
  const preview = `${JSON.stringify(root, null, 2)}\n`;
  if (before === after) return { changed: false, preview };

  if (!opts.dryRun) {
    ensureDirFor(path);
    const backup = opts.backup !== false ? backupFile(path) : undefined;
    writeFileSync(path, preview, "utf8");
    return { changed: true, backup, preview };
  }
  return { changed: true, preview };
}

type TomlBrooklyn = { command?: string; args?: string[]; type?: string; url?: string };

function serializeToml(root: { mcp_servers?: Record<string, TomlBrooklyn> }): string {
  let text = "# Generated by Brooklyn MCP\n\n";
  const servers = root.mcp_servers ?? {};
  for (const [name, def] of Object.entries(servers)) {
    text += `[mcp_servers.${name}]\n`;
    if (def.command) text += `command = "${def.command}"\n`;
    if (def.args) text += `args = [${def.args.map((s) => `"${s}"`).join(", ")}]\n`;
    if (def.type) text += `type = "${def.type}"\n`;
    if (def.url) text += `url = "${def.url}"\n`;
    text += "\n";
  }
  return text.trim();
}

export function patchTomlBrooklyn(
  path: string,
  value: TomlBrooklyn | null,
  opts: PatchOptions = {},
): {
  changed: boolean;
  backup?: string;
  preview: string;
} {
  // Best-effort TOML handling: parse; if fails, start minimal
  const tomlText = existsSync(path) ? readFileSync(path, "utf8") : "";
  let cfg: Record<string, unknown> = {};
  try {
    cfg = tomlText ? TOML.parse(tomlText) : {};
  } catch {
    cfg = {};
  }
  if (typeof cfg !== "object" || cfg === null) cfg = {} as Record<string, unknown>;
  const root = cfg as { mcp_servers?: Record<string, TomlBrooklyn> };
  if (!root.mcp_servers || typeof root.mcp_servers !== "object")
    root.mcp_servers = {} as Record<string, TomlBrooklyn>;

  const before = JSON.stringify(root);
  if (value === null) {
    const servers = root.mcp_servers as Record<string, TomlBrooklyn>;
    servers["brooklyn"] = undefined as unknown as TomlBrooklyn;
  } else {
    const servers = root.mcp_servers as Record<string, TomlBrooklyn>;
    servers["brooklyn"] = { ...value } as TomlBrooklyn;
  }
  const after = JSON.stringify(root);
  // Serialize minimal TOML; note: comments/order may change
  const preview = serializeToml(root);

  if (before === after) return { changed: false, preview };
  if (!opts.dryRun) {
    ensureDirFor(path);
    const backup = opts.backup !== false ? backupFile(path) : undefined;
    writeFileSync(path, preview, "utf8");
    return { changed: true, backup, preview };
  }
  return { changed: true, preview };
}

// OpenCode JSON patcher: writes under root.mcp.brooklyn
export function patchOpencodeBrooklyn(
  path: string,
  value:
    | { type: "local"; command: string[]; enabled?: boolean }
    | { type: "remote"; url: string; enabled?: boolean }
    | null,
  opts: PatchOptions = {},
): { changed: boolean; backup?: string; preview: string } {
  let obj: Record<string, unknown> = {};
  if (existsSync(path)) {
    try {
      obj = JSON.parse(readFileSync(path, "utf8"));
    } catch {
      obj = {};
    }
  }
  if (typeof obj !== "object" || obj === null) obj = {} as Record<string, unknown>;
  const root = obj as { mcp?: Record<string, unknown> };
  if (!root.mcp || typeof root.mcp !== "object") root.mcp = {} as Record<string, unknown>;

  const before = JSON.stringify(root);
  if (value === null) {
    (root.mcp as Record<string, unknown>)["brooklyn"] = undefined;
  } else {
    (root.mcp as Record<string, unknown>)["brooklyn"] = {
      ...value,
      enabled: value.enabled ?? true,
    };
  }
  const after = JSON.stringify(root);
  const preview = `${JSON.stringify(root, null, 2)}\n`;
  if (before === after) return { changed: false, preview };
  if (!opts.dryRun) {
    ensureDirFor(path);
    const backup = opts.backup !== false ? backupFile(path) : undefined;
    writeFileSync(path, preview, "utf8");
    return { changed: true, backup, preview };
  }
  return { changed: true, preview };
}
