#!/usr/bin/env bun

/**
 * Extract help text from fenced code blocks in markdown files
 *
 * Looks for blocks like:
 * ```help-text-mcp-setup
 * Content here
 * ```
 *
 * Extracts to src/generated/help/ for CLI embedding
 */

import { mkdir, readFile, readdir, writeFile } from "node:fs/promises";
import { dirname, join } from "node:path";

interface HelpBlock {
  name: string;
  content: string;
  source: string;
}

const DOCS_DIR = "docs";
const OUTPUT_DIR = "src/generated/help";
const HELP_BLOCK_REGEX = /```help-text-([a-z-]+)\n([\s\S]*?)```/g;

async function findMarkdownFiles(dir: string): Promise<string[]> {
  const files: string[] = [];

  async function scan(currentDir: string) {
    const entries = await readdir(currentDir, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = join(currentDir, entry.name);

      if (entry.isDirectory()) {
        await scan(fullPath);
      } else if (entry.name.endsWith(".md")) {
        files.push(fullPath);
      }
    }
  }

  await scan(dir);
  return files;
}

async function extractHelpBlocks(filePath: string): Promise<HelpBlock[]> {
  const content = await readFile(filePath, "utf-8");
  const blocks: HelpBlock[] = [];

  let match: RegExpExecArray | null = HELP_BLOCK_REGEX.exec(content);
  while (match !== null) {
    const [, name, blockContent] = match;
    if (name && blockContent) {
      blocks.push({
        name,
        content: blockContent.trim(),
        source: filePath,
      });
    }
    match = HELP_BLOCK_REGEX.exec(content);
  }

  return blocks;
}

async function generateHelpFiles(blocks: HelpBlock[]): Promise<void> {
  // Ensure output directory exists
  await mkdir(OUTPUT_DIR, { recursive: true });

  // Group blocks by name
  const blockMap = new Map<string, HelpBlock>();

  for (const block of blocks) {
    if (blockMap.has(block.name)) {
      console.warn(`Duplicate help block: ${block.name} (keeping first one)`);
      continue;
    }
    blockMap.set(block.name, block);
  }

  // Generate individual help files
  for (const [name, block] of blockMap) {
    const fileName = `${name}.txt`;
    const filePath = join(OUTPUT_DIR, fileName);

    await writeFile(filePath, block.content);
    console.log(`Generated: ${filePath}`);
  }

  // Generate TypeScript module for importing
  const exportLines = Array.from(blockMap.keys()).map((name) => {
    const varName = name.replace(/-/g, "_").toUpperCase();
    const block = blockMap.get(name);
    if (!block) throw new Error(`Block not found: ${name}`);
    return `export const ${varName} = \`${block.content.replace(/`/g, "\\`")}\`;`;
  });

  const tsContent = `// Auto-generated help text from markdown docs
// Do not edit this file directly - edit the markdown sources instead

${exportLines.join("\n\n")}

// Help text lookup map
export const HELP_TEXT = {
${Array.from(blockMap.keys())
  .map((name) => {
    const varName = name.replace(/-/g, "_").toUpperCase();
    return `  "${name}": ${varName}`;
  })
  .join(",\n")}
} as const;
`;

  const tsPath = join(OUTPUT_DIR, "index.ts");
  await writeFile(tsPath, tsContent);
  console.log(`Generated: ${tsPath}`);
}

async function main() {
  try {
    console.log("üîç Scanning for markdown files...");
    const markdownFiles = await findMarkdownFiles(DOCS_DIR);
    console.log(`Found ${markdownFiles.length} markdown files`);

    console.log("üìù Extracting help blocks...");
    const allBlocks: HelpBlock[] = [];

    for (const file of markdownFiles) {
      const blocks = await extractHelpBlocks(file);
      if (blocks.length > 0) {
        console.log(`  ${file}: ${blocks.length} help blocks`);
        allBlocks.push(...blocks);
      }
    }

    console.log(`üì¶ Extracted ${allBlocks.length} total help blocks`);

    if (allBlocks.length === 0) {
      console.log("‚ÑπÔ∏è  No help blocks found - nothing to generate");
      return;
    }

    console.log("üèóÔ∏è  Generating help files...");
    await generateHelpFiles(allBlocks);

    console.log("‚úÖ Help text extraction complete!");

    // Summary
    console.log("\nüìã Summary:");
    const uniqueNames = new Set(allBlocks.map((b) => b.name));
    for (const name of uniqueNames) {
      const block = allBlocks.find((b) => b.name === name);
      if (!block) continue;
      console.log(`  ${name}: ${block.source}`);
    }
  } catch (error) {
    console.error("‚ùå Help text extraction failed:", error);
    process.exit(1);
  }
}

if (import.meta.main) {
  main();
}
