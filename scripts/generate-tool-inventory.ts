#!/usr/bin/env bun
/**
 * Generate Tool Inventory
 *
 * Creates deterministic, sorted tool inventory files for documentation.
 * Output files are committed to enable discoverability by humans and AI agents.
 *
 * Outputs:
 *   - docs/tools/tool-inventory.json  (machine-readable, full schemas)
 *   - docs/tools/tool-inventory.md    (human-readable, markdown tables)
 *
 * Design principles:
 *   - Idempotent: Same input always produces identical output
 *   - Sorted: Alphabetical by tool name (no churn on regeneration)
 *   - No timestamps: Avoids unnecessary commit diffs
 *   - Deterministic JSON: Sorted keys throughout
 *
 * Usage:
 *   bun scripts/generate-tool-inventory.ts
 *   bun scripts/generate-tool-inventory.ts --check  # CI mode: fail if drift detected
 *
 * @see docs/architecture/decisions/adr-tool-inventory-generation.md
 */

import { existsSync, mkdirSync, readFileSync, writeFileSync } from "node:fs";
import { join } from "node:path";
import type { Tool } from "@modelcontextprotocol/sdk/types.js";

// Import onboarding tools
import { OnboardingTools } from "../src/core/onboarding-tools.js";
import { type EnhancedTool, getAllTools } from "../src/core/tool-definitions.js";

const PROJECT_ROOT = join(import.meta.dir, "..");
const OUTPUT_DIR = join(PROJECT_ROOT, "docs/tools");
const JSON_OUTPUT = join(OUTPUT_DIR, "tool-inventory.json");
const MD_OUTPUT = join(OUTPUT_DIR, "tool-inventory.md");

interface ToolInventoryEntry {
  name: string;
  category: string;
  description: string;
  inputSchema?: unknown;
  examples?: unknown[];
  errors?: unknown[];
  nativeDependencies?: string[];
}

interface ToolInventory {
  $schema: string;
  version: string;
  generatedBy: string;
  totalTools: number;
  categories: string[];
  tools: ToolInventoryEntry[];
}

/**
 * Sort object keys recursively for deterministic JSON output
 */
function sortObjectKeys(obj: unknown): unknown {
  if (obj === null || typeof obj !== "object") {
    return obj;
  }

  if (Array.isArray(obj)) {
    return obj.map(sortObjectKeys);
  }

  const sorted: Record<string, unknown> = {};
  const keys = Object.keys(obj as Record<string, unknown>).sort();
  for (const key of keys) {
    sorted[key] = sortObjectKeys((obj as Record<string, unknown>)[key]);
  }
  return sorted;
}

/**
 * Convert EnhancedTool to inventory entry
 */
function toInventoryEntry(tool: EnhancedTool): ToolInventoryEntry {
  const entry: ToolInventoryEntry = {
    name: tool.name,
    category: tool.category,
    description: tool.description || "",
  };

  if (tool.inputSchema) {
    entry.inputSchema = tool.inputSchema;
  }
  if (tool.examples && tool.examples.length > 0) {
    entry.examples = tool.examples;
  }
  if (tool.errors && tool.errors.length > 0) {
    entry.errors = tool.errors;
  }
  if (tool.nativeDependencies && tool.nativeDependencies.length > 0) {
    entry.nativeDependencies = tool.nativeDependencies;
  }

  return entry;
}

/**
 * Convert MCP Tool to inventory entry
 */
function mcpToolToInventoryEntry(tool: Tool, category: string): ToolInventoryEntry {
  return {
    name: tool.name,
    category,
    description: tool.description || "",
    inputSchema: tool.inputSchema,
  };
}

/**
 * Generate the tool inventory
 */
function generateInventory(): ToolInventory {
  // Get core tools from tool-definitions.ts
  const coreTools = getAllTools();

  // Get onboarding tools
  const onboardingTools = OnboardingTools.getTools();

  // Convert to inventory entries
  const coreEntries = coreTools.map(toInventoryEntry);
  const onboardingEntries = onboardingTools.map((t) => mcpToolToInventoryEntry(t, "onboarding"));

  // Combine and sort alphabetically by name
  const allEntries = [...coreEntries, ...onboardingEntries].sort((a, b) =>
    a.name.localeCompare(b.name),
  );

  // Extract unique categories, sorted
  const categories = [...new Set(allEntries.map((t) => t.category))].sort();

  // Get version from package.json
  const packageJson = JSON.parse(readFileSync(join(PROJECT_ROOT, "package.json"), "utf-8"));

  return {
    $schema: "./tool-inventory.schema.json",
    version: packageJson.version,
    generatedBy: "scripts/generate-tool-inventory.ts",
    totalTools: allEntries.length,
    categories,
    tools: allEntries,
  };
}

/**
 * Generate markdown documentation
 */
function generateMarkdown(inventory: ToolInventory): string {
  const lines: string[] = [
    "# Brooklyn MCP Tool Inventory",
    "",
    `**Version**: ${inventory.version}  `,
    `**Total Tools**: ${inventory.totalTools}  `,
    `**Categories**: ${inventory.categories.length}`,
    "",
    "> This file is auto-generated by `scripts/generate-tool-inventory.ts`.",
    "> Do not edit directly - changes will be overwritten.",
    "> See [ADR: Tool Inventory Generation](../architecture/decisions/adr-tool-inventory-generation.md) for details.",
    "",
    "## Quick Links",
    "",
    "- [JSON Inventory](./tool-inventory.json) - Machine-readable for AI agents",
    "- [Tool Categories](#categories)",
    "- [Full Tool List](#all-tools)",
    "",
    "---",
    "",
    "## Categories",
    "",
  ];

  // Category summary table
  const categoryCount: Record<string, number> = {};
  for (const tool of inventory.tools) {
    categoryCount[tool.category] = (categoryCount[tool.category] || 0) + 1;
  }

  lines.push("| Category | Tools | Description |");
  lines.push("|----------|-------|-------------|");

  const categoryDescriptions: Record<string, string> = {
    "browser-lifecycle": "Launch, close, and manage browser instances",
    navigation: "URL navigation and page loading",
    interaction: "Click, type, hover, drag-drop, and form interactions",
    "content-capture": "Screenshots, HTML extraction, and content analysis",
    rendering: "PDF rendering and document display",
    "image-processing": "SVG compression and PNG conversion",
    documentation: "Help, docs, and tool discovery",
    javascript: "Script injection and expression evaluation",
    styling: "CSS analysis, specificity debugging, and style inspection",
    discovery: "Element finding, selector generation, and DOM analysis",
    "pdf-analysis": "PDF text extraction, table detection, and layout analysis",
    onboarding: "Getting started, status, examples, and troubleshooting",
  };

  for (const category of inventory.categories) {
    const count = categoryCount[category];
    const desc = categoryDescriptions[category] || "";
    lines.push(`| [${category}](#${category.replace(/[^a-z0-9]/g, "-")}) | ${count} | ${desc} |`);
  }

  lines.push("");
  lines.push("---");
  lines.push("");
  lines.push("## All Tools");
  lines.push("");

  // Group tools by category
  for (const category of inventory.categories) {
    const categoryTools = inventory.tools.filter((t) => t.category === category);

    lines.push(`### ${category}`);
    lines.push("");
    lines.push("| Tool | Description |");
    lines.push("|------|-------------|");

    for (const tool of categoryTools) {
      // Escape pipes in description
      const desc = tool.description.replace(/\|/g, "\\|").replace(/\n/g, " ");
      lines.push(`| \`${tool.name}\` | ${desc} |`);
    }

    lines.push("");
  }

  lines.push("---");
  lines.push("");
  lines.push("## Usage");
  lines.push("");
  lines.push("### For AI Agents");
  lines.push("");
  lines.push("Fetch the JSON inventory for programmatic access:");
  lines.push("");
  lines.push("```");
  lines.push("# Raw JSON from GitHub");
  lines.push(
    "https://raw.githubusercontent.com/fulmenhq/brooklyn-mcp/main/docs/tools/tool-inventory.json",
  );
  lines.push("```");
  lines.push("");
  lines.push("### For Humans");
  lines.push("");
  lines.push("Browse tools by category above, or search this page for specific capabilities.");
  lines.push("");

  return lines.join("\n");
}

/**
 * Format content using prettier (global install)
 * This ensures generated output matches what prettier would produce
 */
async function formatWithPrettier(content: string, parser: string): Promise<string> {
  const proc = Bun.spawn(["prettier", "--parser", parser], {
    stdin: "pipe",
    stdout: "pipe",
    stderr: "pipe",
  });

  // Write content to stdin
  proc.stdin.write(content);
  proc.stdin.end();

  // Read stdout
  const output = await new Response(proc.stdout).text();
  const exitCode = await proc.exited;

  if (exitCode !== 0) {
    const stderr = await new Response(proc.stderr).text();
    throw new Error(`prettier failed (exit ${exitCode}): ${stderr}`);
  }

  return output;
}

/**
 * Main execution
 */
async function main() {
  const checkMode = process.argv.includes("--check");

  console.log("Generating tool inventory...");

  // Generate inventory
  const inventory = generateInventory();
  console.log(`  Found ${inventory.totalTools} tools in ${inventory.categories.length} categories`);

  // Ensure output directory exists
  if (!existsSync(OUTPUT_DIR)) {
    mkdirSync(OUTPUT_DIR, { recursive: true });
  }

  // Generate JSON (sorted keys for determinism)
  const rawJsonContent = `${JSON.stringify(sortObjectKeys(inventory), null, 2)}\n`;

  // Generate Markdown
  const rawMdContent = generateMarkdown(inventory);

  // Format with prettier to ensure output matches what prettier would produce
  const jsonContent = await formatWithPrettier(rawJsonContent, "json");
  const mdContent = await formatWithPrettier(rawMdContent, "markdown");

  if (checkMode) {
    // CI mode: check for drift
    let hasChanges = false;

    if (existsSync(JSON_OUTPUT)) {
      const existing = readFileSync(JSON_OUTPUT, "utf-8");
      if (existing !== jsonContent) {
        console.error("ERROR: tool-inventory.json is out of date");
        hasChanges = true;
      }
    } else {
      console.error("ERROR: tool-inventory.json does not exist");
      hasChanges = true;
    }

    if (existsSync(MD_OUTPUT)) {
      const existing = readFileSync(MD_OUTPUT, "utf-8");
      if (existing !== mdContent) {
        console.error("ERROR: tool-inventory.md is out of date");
        hasChanges = true;
      }
    } else {
      console.error("ERROR: tool-inventory.md does not exist");
      hasChanges = true;
    }

    if (hasChanges) {
      console.error("\nRun 'bun scripts/generate-tool-inventory.ts' to regenerate.");
      process.exit(1);
    }

    console.log("✓ Tool inventory is up to date");
    return;
  }

  // Write files
  writeFileSync(JSON_OUTPUT, jsonContent);
  console.log(`  Written: ${JSON_OUTPUT}`);

  writeFileSync(MD_OUTPUT, mdContent);
  console.log(`  Written: ${MD_OUTPUT}`);

  console.log("\n✓ Tool inventory generated successfully");
}

main().catch((err) => {
  console.error("Failed to generate tool inventory:", err);
  process.exit(1);
});
