# Git Squash/Rebase Standard Operating Procedure

**Version**: 1.0.0
**Status**: Active
**Category**: Development Process
**Tags**: [git, rebase, squash, version-control, sop]

---

## Overview

This document describes the standard operating procedure for squashing multiple commits into a clean commit history before pushing to the remote repository. This process is particularly useful when preparing a feature branch for merge or when cleaning up work-in-progress commits.

## When to Use

- Before pushing a feature branch that contains many incremental commits
- When preparing a pull request with a cleaner commit history
- After completing a phase of work with multiple checkpoint commits
- When commit messages contain project-specific identifiers that shouldn't be in the final history

## Prerequisites

- Git version 2.0 or higher
- Understanding of git reset, rebase, and commit concepts
- Backup strategy in place (automatic or manual)

## Safety First: Always Create a Backup

Before any history rewriting operation, **always** create a backup branch:

```bash
# Create a timestamped backup branch
git branch backup/pre-squash-$(date +%Y%m%d-%H%M%S)
```

This saved us during our squash operation when we needed to recover from an incomplete state.

## Step-by-Step Process

### 1. Identify the Target Commit

First, identify the oldest commit that should NOT be squashed (typically the last pushed commit):

```bash
# View commit history
git log --oneline --decorate --graph -20

# Get the commit hash of the target
git rev-parse HEAD~N  # where N is the number of commits to include
```

### 2. Create Safety Backup

```bash
# Create backup branch at current HEAD
git branch backup/pre-squash-$(date +%Y%m%d-%H%M%S)

# Verify backup was created
git branch -vv | grep backup
```

### 3. Perform Soft Reset

Use soft reset to preserve all changes in the staging area:

```bash
# Reset to the commit AFTER which you want to squash everything
git reset --soft <commit-hash>

# Example: Reset to initial commit
git reset --soft $(git rev-list --max-parents=0 HEAD)
```

### 4. Create Clean Commit Message

Prepare a commit message that follows the project's contribution guidelines:

- Summarizes the feature/changes comprehensively
- Excludes project-specific task numbers or phase identifiers
- Follows conventional commit format
- Includes co-author attributions if needed
- Includes AI agent attribution if applicable

For AI agent contributors, always include proper attribution:

```bash
# Create commit message file with AI attribution
cat > /tmp/squash-message.txt << 'EOF'
feat: implement comprehensive feature with detailed subsystems

- Major component A with specific capabilities
- Integration layer B with external systems
- Testing infrastructure achieving X% coverage
- Documentation for user guides and architecture

Generated by [AI Agent Name] under supervision of @[human-maintainer]

Co-authored-by: [AI Agent Name] <noreply@fulmen.ai>
EOF
```

For human contributors:

```bash
# Create commit message file
cat > /tmp/squash-message.txt << 'EOF'
feat: implement comprehensive feature with detailed subsystems

- Major component A with specific capabilities
- Integration layer B with external systems
- Testing infrastructure achieving X% coverage
- Documentation for user guides and architecture

Author: Name <email@example.com>
EOF
```

### 5. Create the Squashed Commit

```bash
# Option A: With pre-commit hooks (recommended)
git add -A
git commit -F /tmp/squash-message.txt

# Option B: Bypass hooks if they're causing issues
git add -A
git commit --no-verify -F /tmp/squash-message.txt
```

### 6. Handle Pre-commit Hook Issues

If pre-commit hooks fail:

```bash
# First, verify code actually passes tests
bun run check-all  # or your test command

# If tests pass but hooks fail, bypass hooks
git commit --no-verify -F /tmp/squash-message.txt
```

Common issues:

- **Type checking errors**: Often cache-related in hook context
- **Auto-formatters**: May modify files during commit - stage changes and re-commit

### 7. Verify Final State

```bash
# Check commit history
git log --oneline --decorate --graph -5

# Verify working directory is clean
git status
```

### 8. Push Changes

```bash
# Push to remote (may require force push)
git push origin <branch-name> --force-with-lease

# Or if pushing to a different remote
git push <remote-name> <branch-name> --force-with-lease
```

### 9. Clean Up Backup Branches

After successfully pushing the squashed commit to remote, clean up backup branches:

```bash
# List backup branches
git branch | grep backup

# Delete backup branch (local only)
git branch -D backup/pre-squash-YYYYMMDD-HHMMSS

# Delete backup branch from remote
git push origin --delete backup/pre-squash-YYYYMMDD-HHMMSS
```

## Best Practices

1. **Always backup before squashing** - Create timestamped backup branches
2. **Test before squashing** - Ensure all tests pass before rewriting history
3. **Use descriptive commit messages** - The squashed commit should be self-contained
4. **Exclude internal references** - Remove task IDs, phase numbers, "WIP" markers
5. **Handle binary files carefully** - Large files may need special attention
6. **Communicate with team** - Let others know before force-pushing
7. **Clean up backup branches** - Remove backup branches after successful push to remote

## Common Patterns

### Two-Commit Structure

For a clean "initial + feature" structure:

```bash
# Starting from: initial -> commit1 -> commit2 -> ... -> commitN
git reset --soft <initial-commit-hash>
git add -A
git commit -m "feat: comprehensive feature implementation"
# Result: initial -> feature
```

### Interactive Rebase Alternative

For more granular control:

```bash
git rebase -i <target-commit>
# Mark commits as 'squash' or 'fixup' in editor
```

## Troubleshooting

### Problem: Empty Commit After Reset

**Symptom**: `git status` shows changes but commit appears empty
**Solution**: Ensure all changes are staged with `git add -A`

### Problem: Pre-commit Hooks Failing

**Symptom**: Hooks fail but manual tests pass
**Solution**: Use `--no-verify` flag or fix hook configuration

### Problem: Lost Commits

**Symptom**: Commits disappeared after reset
**Solution**: Use backup branch or reflog to recover

## Example Session

```bash
# 1. Check current state
git log --oneline -10

# 2. Create backup
git branch backup/pre-squash-$(date +%Y%m%d-%H%M%S)

# 3. Soft reset to target
git reset --soft fdf2da7

# 4. Create commit with proper attribution
cat > /tmp/msg.txt << 'EOF'
feat: implement task runner with comprehensive tooling

- Local and remote execution support
- Workflow scheduling and state management
- 81% test coverage with deterministic tests
- Developer documentation and examples

Generated by Paris Brooklyn under supervision of @3leapsdave

Co-authored-by: Paris Brooklyn <noreply@fulmen.ai>
EOF

git add -A
git commit -F /tmp/msg.txt

# 5. Push changes
git push origin feature-branch --force-with-lease

# 6. Clean up backup branch after successful push
git branch -D backup/pre-squash-20250807-153000
git push origin --delete backup/pre-squash-20250807-153000

# 7. Verify
git log --oneline -3
```

## Recommended Tools and Resources

This SOP provides command line examples that can be used as reference when working with GUI tools:

### GUI Tools for Complex Rebases

- **GitKraken**: Visual interactive rebase interface (see command line examples for equivalent operations)
- **Fork**: Excellent conflict resolution capabilities (see command line examples for equivalent operations)
- **VS Code GitLens**: In-editor rebase and history support (see command line examples for equivalent operations)

When using GUI tools, refer to the command line examples in this document to understand the underlying operations.

## References

- [Git Documentation - Rewriting History](https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History)
- [Conventional Commits](https://www.conventionalcommits.org/)
- Project-specific commit message guidelines in [CONTRIBUTORS.md](../../CONTRIBUTORS.md)
- [AGENT.md](../../AGENT.md) for AI agent contribution standards
