# Brooklyn MCP Deployment SOP - The Hard-Learned Way

**NEVER AGAIN: A 24-hour debugging session distilled into process**

## üö® CRITICAL WARNING

This SOP was written after early (pre-release) process failures where commits and pushes ran before validating repository status:

- Broken prepush hooks that didn't run proper validation
- Force-pushing with --force-with-lease without quality checks
- Orphaned tags (see history for v1.6.1) requiring emergency cleanup
- Unstaged files pushed to production

**These steps are MANDATORY. No shortcuts. No exceptions.**

---

## Pre-Commit Checklist - BEFORE `git add`

### 1. Quality Validation Per File

```bash
# For EVERY file you modify - run these commands:
bun run check:file:fix src/path/to/file.ts   # Auto-fix what's possible
bun run check:file src/path/to/file.ts       # Verify all checks pass
```

> You can achieve the same thing with `bun run check-all`. The "file-at-a-time" targets are useful when multiple activities are in-flight at once in a repo instance.

**‚ùå NEVER stage files that fail quality checks**

### 2. Verify Hook Configuration

```bash
# Ensure prepush runs complete validation
grep "precommit" package.json | grep prepush
# Should show: "prepush": "bun run precommit && bun run test:prepush"

# Verify precommit hook exists and works
ls -la .husky/pre-commit
bun run precommit  # Should pass completely
```

### 3. Stage Only Clean Files

```bash
git status                    # Check for unstaged changes
git add <specific-files>      # NEVER use git add -A without review
git status                    # Verify only intended files staged
```

**‚ùå LIMITED PERMISSION to commit with unstaged files sitting in working directory**

> This should only happen when approved by a supervisor, either to handle an emergency fix or because of a complex task in progress. This should NEVER be done in a commit that is intended to be pushed or tagged.

### 4. Commit Quality Validation

```bash
# This runs automatically via pre-commit hook:
# - Format code (biome format)
# - Type check (tsc --noEmit)
# - Lint validation (biome check)
# - Fast tests (vitest precommit config)

git commit -m "$(cat <<'EOF'
<type>: <description>

- [specific change details]
- [business reason]

Generated by [AI Agent Name] under supervision of @3leapsdave

Co-Authored-By: [AI Agent Name] <noreply@fulmenhq.com>
EOF
)"
```

---

## Pre-Push Checklist - BEFORE `git push`

### 1. Comprehensive Validation

```bash
# This should run automatically, but verify:
bun run prepush
# package.json:
#   "prepush": "bun run validate:clean-working-tree:strict && bun run precommit && bun run build:artifacts:local && bun run release:validate"

# Manual verification if needed:
bun run validate:clean-working-tree:strict   # Ensure no stray changes
bun run precommit                            # Format + typecheck + lint + fast tests
bun run release:validate                     # Full gate: tests + build + licenses + binaries
```

**Expected Results:**

- ‚úÖ All formatting applied automatically
- ‚úÖ Zero TypeScript compilation errors
- ‚úÖ Zero linting violations
- ‚úÖ Fast tests: ~475 tests passed
- ‚úÖ Full tests: ~799 tests passed, ~98 skipped

### 2. Push with Validation

```bash
git push origin main
# Pre-push hook runs automatically and MUST pass

# If it fails:
# 1. Fix the issues (don't use --no-verify unless emergency)
# 2. Commit fixes
# 3. Re-run prepush validation
# 4. Push again
```

**üìã Additional Pre-Push Options:**

- **For multiple commits**: See [Git Squash & Rebase SOP](git-squash-rebase-sop.md) for approved squashing/rebase process
- **For feature branches**: Use squash-and-merge or rebase workflow as defined in team SOP

### 3. Verify Push Success

```bash
git log --oneline -3        # Confirm your commits are on origin
git status                  # Should show "up to date with origin/main"
```

---

## Version Release Checklist - For Tags

### 1. Version Bump Process

```bash
# NEVER manually edit VERSION or package.json
bun run version:bump:patch   # or minor/major
git status                   # Verify version files updated
```

### 2. Changelog Update

```bash
# Update CHANGELOG.md with:
# - Version number and date
# - Clear description of changes
# - Note any breaking changes
# - Reference any orphaned versions

git add CHANGELOG.md VERSION package.json
```

### 3. Release Commit

```bash
git commit -m "$(cat <<'EOF'
chore: v1.X.X - <brief description>

- [list of changes]
- [process improvements]
- [any special notes]

Generated by [AI Agent] under supervision of @3leapsdave

Co-Authored-By: [AI Agent] <noreply@fulmenhq.com>
EOF
)"
```

### 4. Final Validation Before Tag

> DO NOT TAG (if tag is intended for remote sync) UNTIL PUSH IS SUCCESSFUL

```bash
bun run prepush              # MUST pass completely
git push origin main         # Push release commit first
git log --oneline -2         # Verify commit is on origin
```

### 5. Tag Creation and Push

```bash
git tag v1.X.X
git push origin v1.X.X

# If pre-push hook fails due to browser timeouts (expected locally):
git push origin v1.X.X --no-verify  # ONLY for browser timeout issues
```

---

## Emergency Recovery Procedures

### When Tags Need Deletion/Recreation

```bash
# Delete problematic tag from origin
git push origin :v1.X.X

# Fix the issues
git add <fixed-files>
git commit -m "fix: resolve deployment issues"

# Bump version (orphan the broken version)
bun run version:bump:patch
# Update CHANGELOG noting orphaned version
git add -A
git commit -m "chore: v1.X.Y - fixes deployment issues"

# Push and retag
git push origin main
git tag v1.X.Y
git push origin v1.X.Y
```

### When Force Push Required

**‚ö†Ô∏è EXTREME CAUTION - Only use when repo is broken**

1. **Document the reason** in commit message
2. **Get explicit approval** from @3leapsdave or other designated supervisor
3. **Notify team** of force push
4. **Use --force-with-lease** instead of --force

```bash
# Emergency force push (with documentation)
git push origin main --force-with-lease -m "EMERGENCY: broken deployment pipeline fixed"
```

**üí° Alternative**: Consider using [Git Squash & Rebase SOP](git-squash-rebase-sop.md) to clean up commits before pushing instead of force-push

---

## Common Failure Points & Solutions

### ‚ùå "prepush script doesn't run full validation"

**Root cause**: prepush only ran tests, not format/lint/typecheck/build/release validation

```bash
# Fix in package.json (current pattern):
"prepush": "bun run validate:clean-working-tree:strict && bun run precommit && bun run build:artifacts:local && bun run release:validate"
```

### ‚ùå "Tests pass locally but fail on tag push"

**Root cause**: Browser integration tests timeout in CI
**Solution**: Expected for local dev, use --no-verify for tag push only

### ‚ùå "Force-with-lease still required"

**Root cause**: Commits pushed without quality validation
**Solution**: Always run full prepush before any git operations

### ‚ùå "Unstaged files during deployment"

**Root cause**: Modified files not committed before version operations
**Solution**: Always check git status, never leave working directory dirty

---

## Quality Gate Requirements

### Pre-Commit Gates (Fast - ~15 seconds)

- ‚úÖ Code formatting via biome
- ‚úÖ TypeScript compilation
- ‚úÖ Linting validation
- ‚úÖ Unit tests + fast integration tests

### Pre-Push Gates (Comprehensive - ~60 seconds)

- ‚úÖ All pre-commit validations
- ‚úÖ Full test suite (unit + integration + e2e)
- ‚úÖ Browser automation tests
- ‚úÖ Protocol compliance validation

### Zero Tolerance Policy

- ‚ùå No bypassing quality gates without documented emergency
- ‚ùå No committing failing code "to fix later"
- ‚ùå No manual version editing
- ‚ùå No force-push without approval

---

## Process Attribution

**This SOP written by**: üåâ Paris Brooklyn (MCP Platform Architect)  
**Approved by**: @3leapsdave (20-Aug-2025)
**Based on emergency fixes**: August 20, 2025 - 24-hour deployment crisis  
**Validated through**: Successful v1.6.2 release with restored process integrity  
**Next review**: Every major version release or after any deployment issues

**Remember**: These steps exist because we LIVED through the pain of not having them. Every shortcut creates technical debt that compounds into deployment nightmares.

---

_"Bridge capabilities with precision, not recklessness"_ - üåâ Paris Brooklyn
